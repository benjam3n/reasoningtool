---
// Paginated.astro — viewport-height pages with nav chips
// Wraps child <section> elements as full-viewport slides.
// Long sections get split into actual separate pages.
// Number buttons on the right side for multi-page content.

interface Props {
  pageGroup?: string;
  pageIndex?: number;
}

const { pageGroup = '', pageIndex = 0 } = Astro.props;
---

<div class="paginated" id="paginated" data-page-group={pageGroup} data-page-index={pageIndex}>
  <nav class="paginated__chips">
    <a href="/" class="pg-chip pg-chip--home">Skills</a>
    <a href="/installation" class="pg-chip">Install</a>
    <a href="/tools" class="pg-chip">Tools</a>
    <a href="/faq" class="pg-chip">FAQ</a>
    <a href="/about" class="pg-chip">About</a>
    <a href="/visuals" class="pg-chip">Visuals</a>
    <button class="pg-chip pg-github" data-url="https://github.com/benjam3n/reasoningtool">GitHub</button>
  </nav>
  <div class="paginated__body">
    <div class="paginated__slides">
      <slot />
    </div>
    <div class="paginated__page-nums" id="pg-nums"></div>
  </div>
</div>

<style>
  :global(body) {
    overflow: hidden;
    height: 100vh;
  }

  .paginated {
    position: fixed;
    inset: 0;
    overflow: hidden;
    background: var(--color-bg);
    display: flex;
    flex-direction: column;
  }

  .paginated__chips {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35em;
    padding: var(--sp-2) var(--sp-3);
    flex-shrink: 0;
    position: relative;
    z-index: 10;
  }

  .pg-chip {
    display: inline-block;
    padding: 0.3em 0.7em;
    border: 1px solid var(--color-accent);
    border-radius: 4px;
    font-family: var(--font-sans);
    font-size: var(--text-xs);
    font-weight: 500;
    text-decoration: none;
    color: var(--color-accent);
    background: var(--color-accent-subtle);
    transition: background var(--transition), color var(--transition);
    cursor: pointer;
  }

  .pg-chip:hover {
    background: var(--color-accent);
    color: #fff;
    text-decoration: none;
  }

  .pg-chip--home {
    border-color: var(--color-text-muted);
    color: var(--color-text-muted);
    background: transparent;
  }

  .pg-chip--home:hover {
    background: var(--color-text-muted);
    color: var(--color-bg);
  }

  .paginated__body {
    flex: 1;
    min-height: 0;
    display: flex;
    position: relative;
  }

  .paginated__slides {
    flex: 1;
    min-width: 0;
    position: relative;
  }

  .paginated__slides :global(section) {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: none;
    padding: var(--sp-2) var(--sp-5);
    padding-bottom: var(--sp-3);
    box-sizing: border-box;
  }

  .paginated__slides :global(section.active) {
    display: block;
  }

  .paginated__page-nums {
    display: flex;
    flex-direction: column;
    gap: 0.4em;
    padding: var(--sp-2) var(--sp-2);
    flex-shrink: 0;
    z-index: 20;
  }

  .paginated__page-nums :global(.pg-num) {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 3rem;
    height: 3rem;
    border: 1px solid var(--color-border);
    border-radius: 6px;
    font-family: var(--font-mono);
    font-size: var(--text-lg);
    font-weight: 600;
    color: var(--color-text-muted);
    background: var(--color-surface);
    cursor: pointer;
    transition: background var(--transition), color var(--transition), border-color var(--transition);
    user-select: none;
  }

  .paginated__page-nums :global(.pg-num:hover) {
    color: var(--color-accent);
    border-color: var(--color-accent);
  }

  .paginated__page-nums :global(.pg-num--active) {
    background: var(--color-accent);
    color: #fff;
    border-color: var(--color-accent);
  }

  /* Content card grid */
  .paginated__slides :global(.content-card-grid) {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-auto-rows: min-content;
    gap: var(--sp-2);
    width: 100%;
    align-items: start;
    align-content: start;
    height: auto !important;
  }

  .paginated__slides :global(.content-card) {
    background: var(--color-surface);
    border: 1px solid var(--color-border-light);
    border-radius: 10px;
    padding: var(--sp-2) var(--sp-3);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04), 0 0 0 1px rgba(0, 0, 0, 0.03);
    overflow: visible;
    box-sizing: border-box;
    font-size: var(--text-xs);
    line-height: 1.45;
  }

  .paginated__slides :global(.content-card h2) {
    margin-top: 0 !important;
    font-size: var(--text-base) !important;
    margin-bottom: var(--sp-1) !important;
  }

  .paginated__slides :global(.content-card h3) {
    margin-top: 0 !important;
    font-size: var(--text-sm) !important;
    margin-bottom: var(--sp-1) !important;
  }

  .paginated__slides :global(.content-card > :last-child) {
    margin-bottom: 0 !important;
  }

  .paginated__slides :global(.content-card p) {
    margin-top: var(--sp-1) !important;
    margin-bottom: var(--sp-1) !important;
  }

  .paginated__slides :global(.content-card ul),
  .paginated__slides :global(.content-card ol) {
    margin-top: var(--sp-1) !important;
    margin-bottom: var(--sp-1) !important;
    padding-left: 1.2em;
  }

  .paginated__slides :global(.content-card table) {
    font-size: var(--text-xs);
  }

  .paginated__slides :global(.content-card pre) {
    font-size: 0.75rem;
    overflow: hidden;
  }
</style>

<script>
  const PAGE_GROUPS: Record<string, string[]> = {
    info: ['/installation', '/tools', '/faq', '/about'],
    visual: ['/', '/visuals'],
  };

  document.addEventListener('astro:page-load', () => {
    const container = document.getElementById('paginated');
    if (!container) return;

    const group = container.dataset.pageGroup || '';
    const pages = PAGE_GROUPS[group] || [];
    const pageIndex = parseInt(container.dataset.pageIndex || '0', 10);

    const slidesWrap = container.querySelector('.paginated__slides');
    if (!slidesWrap) return;

    const sections = Array.from(slidesWrap.querySelectorAll(':scope > section'));
    if (sections.length === 0) return;

    const GRID_INLINE = 'display:grid;grid-template-columns:repeat(3,1fr);grid-auto-rows:min-content;gap:var(--sp-2);width:100%;align-items:start;align-content:start;';

    function makeGrid(): HTMLDivElement {
      const g = document.createElement('div');
      g.className = 'content-card-grid';
      g.style.cssText = GRID_INLINE;
      return g;
    }

    // Card-wrap: group content elements under headings into .card divs
    // This runs before DOM splitting so each card becomes a distributable block
    container.querySelectorAll('.skill-page__content').forEach((content) => {
      const children = Array.from(content.children) as HTMLElement[];
      if (children.length === 0) return;

      const cards: HTMLElement[] = [];
      let currentCard: HTMLElement | null = null;

      children.forEach((el) => {
        const tag = el.tagName.toLowerCase();
        const isHeading = tag === 'h2' || tag === 'h3';
        const isHr = tag === 'hr';

        // Skip hidden h1s and horizontal rules
        if (tag === 'h1' || isHr) {
          el.remove();
          return;
        }

        // Start a new card on each heading
        if (isHeading || !currentCard) {
          currentCard = document.createElement('div');
          currentCard.className = 'content-card';
          cards.push(currentCard);
        }

        currentCard.appendChild(el);
      });

      // Wrap cards in a grid container and replace content
      const grid = makeGrid();
      cards.forEach((card) => grid.appendChild(card));
      content.appendChild(grid);
    });

    // Also card-wrap content on other pages (tables, code blocks, card-grids)
    container.querySelectorAll('.paginated__slides > section').forEach((sec) => {
      const s = sec as HTMLElement;
      if (s.querySelector('.skill-page__content')) return; // already handled
      // Wrap standalone tables and pre blocks in cards
      s.querySelectorAll(':scope > table, :scope > pre').forEach((el) => {
        if (el.parentElement?.classList.contains('content-card')) return;
        const card = document.createElement('div');
        card.className = 'content-card';
        el.parentNode!.insertBefore(card, el);
        card.appendChild(el);
      });
    });

    // Split oversized cards: if a single card is taller than ~75% of viewport,
    // break it into multiple continuation cards so it can span pages.
    // Also splits long lists/tables within cards.
    const maxCardHeight = window.innerHeight * 0.75;

    function splitOversizedCards(grid: Element) {
      const section = grid.closest('section') as HTMLElement;
      const wasHidden = section && !section.classList.contains('active');
      if (wasHidden && section) { section.style.display = 'block'; section.classList.add('active'); }

      // Flatten long lists/tables inside cards first — turn their children into
      // direct card children so the card-level splitter can distribute them
      (grid.querySelectorAll(':scope > .content-card') as NodeListOf<HTMLElement>).forEach((card) => {
        const splittables = Array.from(card.querySelectorAll(':scope > ol, :scope > ul')) as HTMLElement[];
        splittables.forEach((list) => {
          if (list.getBoundingClientRect().height <= maxCardHeight) return;
          // Replace the list with its individual <li> children as separate elements
          const items = Array.from(list.children) as HTMLElement[];
          items.forEach((li) => {
            const wrapper = document.createElement('p');
            wrapper.innerHTML = li.innerHTML;
            list.parentNode!.insertBefore(wrapper, list);
          });
          list.remove();
        });
      });

      // Now split cards that are too tall
      let changed = true;
      while (changed) {
        changed = false;
        const cards = Array.from(grid.querySelectorAll(':scope > .content-card')) as HTMLElement[];
        for (const card of cards) {
          if (card.getBoundingClientRect().height <= maxCardHeight) continue;
          if (card.children.length <= 1) continue; // Can't split a single-element card further

          const heading = card.querySelector('h2, h3');
          const headingText = heading?.textContent || '';
          const children = Array.from(card.children) as HTMLElement[];

          // Clear and redistribute
          card.innerHTML = '';
          let currentCard = card;

          children.forEach((child) => {
            currentCard.appendChild(child);
            if (currentCard.getBoundingClientRect().height > maxCardHeight && currentCard.children.length > 1) {
              child.remove();
              const contCard = document.createElement('div');
              contCard.className = 'content-card';
              const contLabel = document.createElement('h3');
              contLabel.textContent = headingText ? `${headingText} (cont.)` : '(continued)';
              contCard.appendChild(contLabel);
              contCard.appendChild(child);
              grid.insertBefore(contCard, currentCard.nextSibling);
              currentCard = contCard;
              changed = true;
            }
          });
        }
      }

      if (wasHidden && section) { section.style.display = ''; section.classList.remove('active'); }
    }

    container.querySelectorAll('.content-card-grid').forEach(splitOversizedCards);

    // Flatten sections: collect all leaf-level block elements for pagination
    // This unwraps wrapper elements like <article> so their children can be split across pages
    function getLeafBlocks(parent: HTMLElement): HTMLElement[] {
      const blocks: HTMLElement[] = [];
      Array.from(parent.children).forEach((child) => {
        const el = child as HTMLElement;
        const tag = el.tagName.toLowerCase();
        // Unwrap container elements that just wrap other blocks
        // Preserve: BEM divs (class has __), .content-card, .card, .callout
        // Unwrap: article, content-card-grid, and generic wrapper divs
        const shouldPreserve = Array.from(el.classList).some(c =>
          c.includes('__') || c === 'card' || c === 'content-card' || c === 'callout' || c === 'card-grid'
        );
        if (tag === 'article' || (tag === 'div' && el.children.length > 1 && !shouldPreserve)) {
          blocks.push(...getLeafBlocks(el));
        } else {
          blocks.push(el);
        }
      });
      return blocks;
    }

    // Helper: create a section that clones className AND data-astro-cid-* attributes
    function cloneSection(original: HTMLElement): HTMLElement {
      const newSec = document.createElement('section');
      newSec.className = original.className;
      // Copy all Astro scope attributes so scoped CSS applies
      Array.from(original.attributes).forEach(attr => {
        if (attr.name.startsWith('data-astro-cid-')) {
          newSec.setAttribute(attr.name, attr.value);
        }
      });
      return newSec;
    }

    // Split sections into pages by moving elements
    sections.forEach((sec) => {
      const s = sec as HTMLElement;

      // Temporarily show to measure
      s.style.display = 'block';
      s.classList.add('active');
      const viewportHeight = s.clientHeight;

      if (s.scrollHeight <= viewportHeight) {
        s.style.display = '';
        s.classList.remove('active');
        return;
      }

      // Flatten all block elements
      const blocks = getLeafBlocks(s);
      const hasCards = blocks.some(b => b.classList.contains('content-card'));

      // Fully clear the section
      s.innerHTML = '';
      s.style.display = '';
      s.classList.remove('active');

      if (hasCards) {
        // Separate header blocks (before first card), cards, and footer (after last card)
        const headerBlocks: HTMLElement[] = [];
        const footerBlocks: HTMLElement[] = [];
        const cards: HTMLElement[] = [];
        let phase: 'header' | 'cards' | 'footer' = 'header';
        for (let i = 0; i < blocks.length; i++) {
          const b = blocks[i];
          if (b.classList.contains('content-card')) {
            phase = 'cards';
            cards.push(b);
            // Check if remaining blocks are all non-cards (footer)
          } else if (phase === 'header') {
            headerBlocks.push(b);
          } else {
            footerBlocks.push(b);
          }
        }

        // Build first page: header + grid
        headerBlocks.forEach(b => s.appendChild(b));
        let currentGrid = makeGrid();
        s.appendChild(currentGrid);

        let currentPage = s;

        // Add cards one at a time, measuring real overflow via CSS grid
        cards.forEach((card) => {
          currentGrid.appendChild(card);

          // Measure
          currentPage.style.display = 'block';
          currentPage.classList.add('active');
          const overflows = currentPage.scrollHeight > viewportHeight;
          currentPage.style.display = '';
          currentPage.classList.remove('active');

          if (overflows && currentGrid.children.length > 1) {
            // Remove card from this page
            card.remove();

            // Start new page with a fresh grid
            const newPage = cloneSection(s);
            slidesWrap.appendChild(newPage);
            currentPage = newPage;
            currentGrid = makeGrid();
            currentPage.appendChild(currentGrid);
            currentGrid.appendChild(card);
          }
        });

        // Add footer to last page
        footerBlocks.forEach(b => currentPage.appendChild(b));

        // Check if footer caused overflow — if so, move it to new page
        currentPage.style.display = 'block';
        currentPage.classList.add('active');
        if (currentPage.scrollHeight > viewportHeight && currentGrid.children.length > 0) {
          currentPage.style.display = '';
          currentPage.classList.remove('active');
          const newPage = cloneSection(s);
          slidesWrap.appendChild(newPage);
          footerBlocks.forEach(b => newPage.appendChild(b));
          // Also move last card to footer page so it's not alone
          if (currentGrid.children.length > 0) {
            const lastCard = currentGrid.lastElementChild!;
            const footerGrid = makeGrid();
            newPage.insertBefore(footerGrid, newPage.firstChild);
            footerGrid.appendChild(lastCard);
            // Clean up empty grid
            if (currentGrid.children.length === 0) currentGrid.remove();
          }
        } else {
          currentPage.style.display = '';
          currentPage.classList.remove('active');
        }
      } else {
        // Non-card content: use simple scrollHeight splitting
        let currentPage = s;

        blocks.forEach((block) => {
          currentPage.appendChild(block);
          currentPage.style.display = 'block';
          currentPage.classList.add('active');

          if (currentPage.scrollHeight > viewportHeight && currentPage.children.length > 1) {
            block.remove();
            currentPage.style.display = '';
            currentPage.classList.remove('active');

            const newPage = cloneSection(s);
            newPage.appendChild(block);
            slidesWrap.appendChild(newPage);
            currentPage = newPage;
          } else {
            currentPage.style.display = '';
            currentPage.classList.remove('active');
          }
        });

        currentPage.style.display = '';
        currentPage.classList.remove('active');
      }
    });

    // Re-collect all sections after splitting, remove empty ones
    Array.from(slidesWrap.querySelectorAll(':scope > section')).forEach((sec) => {
      if (sec.children.length === 0) sec.remove();
    });
    const finalSections = Array.from(slidesWrap.querySelectorAll(':scope > section')) as HTMLElement[];

    let current = 0;
    const total = finalSections.length;

    // Build number buttons (clear any previous ones first)
    const numsContainer = document.getElementById('pg-nums');
    if (numsContainer) numsContainer.innerHTML = '';
    const numBtns: HTMLButtonElement[] = [];

    if (numsContainer && total > 1) {
      for (let i = 0; i < total; i++) {
        const btn = document.createElement('button');
        btn.className = 'pg-num';
        btn.textContent = String(i + 1);
        btn.addEventListener('click', () => show(i));
        numsContainer.appendChild(btn);
        numBtns.push(btn);
      }
    } else if (numsContainer) {
      numsContainer.style.display = 'none';
    }

    function updateNums() {
      numBtns.forEach((btn, i) => {
        btn.classList.toggle('pg-num--active', i === current);
      });
    }

    function show(index: number) {
      if (index < 0 || index >= total) return;

      finalSections.forEach((s) => s.classList.remove('active'));
      finalSections[index].classList.add('active');

      current = index;
      updateNums();
    }

    function goNextPage() {
      if (pages.length === 0) return;
      const nextIndex = (pageIndex + 1) % pages.length;
      window.location.href = pages[nextIndex];
    }

    function goPrevPage() {
      if (pages.length === 0) return;
      const prevIndex = (pageIndex - 1 + pages.length) % pages.length;
      window.location.href = pages[prevIndex];
    }

    function next() {
      if (current < total - 1) {
        show(current + 1);
      } else {
        goNextPage();
      }
    }

    function prev() {
      if (current > 0) {
        show(current - 1);
      } else {
        goPrevPage();
      }
    }

    // Initialize
    show(0);

    // Keyboard navigation
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); next(); }
      if (e.key === 'ArrowLeft') { e.preventDefault(); prev(); }
    });

    // GitHub toggle buttons — first click arms, second click opens
    document.querySelectorAll('.pg-github').forEach((btn) => {
      const el = btn as HTMLElement;
      const url = el.dataset.url || 'https://github.com/benjam3n/reasoningtool';
      const originalText = el.textContent || 'GitHub';
      let armed = false;

      el.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (armed) {
          window.open(url, '_blank', 'noopener');
          el.textContent = originalText;
          armed = false;
        } else {
          el.textContent = 'Go to GitHub';
          armed = true;
        }
      });

      // Reset if clicking elsewhere
      document.addEventListener('click', () => {
        if (armed) {
          el.textContent = originalText;
          armed = false;
        }
      });
    });

    // Prevent all scroll events globally
    window.addEventListener('wheel', (e) => { e.preventDefault(); }, { passive: false });
    window.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
  });
</script>
